In this file I explain my projects of Software Security.
The aim of this exam is provided the basis of SECURITY and SAFE of systems. In particular these projects are assigned to using
the (static and dinamic) tools. With our knowledges and tools we found the bugs/vulnerabilities of C/Java/php/html system.
Naturally, at the end of this course I did the final write test on others argouments (obfuscation, rule java programming, 
definition of non-termination, Security in the process of Software Development Life Cycle, ... ).


PROJECT 1

Project1 of MATTEO LIBERTI. Matricola: 1712809.
Splint description
The strength of Splint is to be able to identify in the program (in a static way) not only the security vulnerabilities but
also the problems related to the style and completeness of the code, regardless of what came before or after it. 
On the one hand it is advantageous but on the other hand, an excessive number of problems, 
it requires more time to analyze them and in the company time is money. 
A solution, for errors that are related to style and completeness would be to inhibit them, that is, 
to ensure that the system does not report them, however, if there were some that are important, 
we could turn them into "False negatives" (example in A.c with the inactivity of argc). 
A weak and strong point of this tool is that it has its own documentation so it is necessary to have good knowledge of the latter
in order to understand each single problem and find the appropriate solution. 
A further strong point is the possibility given to the programmer to comment: the variables, the methods, etc. to increase 
the information that the tool has, however, this takes a long time and doing it for each type of variable on 1000 lines 
of code involves further additional work. Another negative point is that the tool does not recognize some functions of the libraries 
so it cannot do a vulnerability analysis on these. In conclusion, if the program has syntax errors then it crash.

File Analysis
Before seeing the files let's focus on the structure of the output. This tool reports errors for each function 
in the order in which they were read (or written), so vulnerabilities are not given priority.
For each function the row, the column and the type of error are reported; the code is provided in order to inhibit the problem.
Here another dilemma arises: "Why should I inhibit a type of error rather than having a tool that recognizes which piece of code is not harmful
to my system?". Concluding you must always have the documentation close to understand if the problem identified by Splint is related to the vulnerability
or not.

File A.c:
char *stringcopy(char *str1, char *str2)
{
while (*str2)
*str1++ = *str2++;
return str2;
}
main(int argc, char **argv)
{
char *buffer = (char *)malloc(16 * sizeof(char));
stringcopy(buffer, argv[1]);
printf("%s\n", buffer);
}


We analyze errors based on the order and function in which they are located:
  1. Stringcopy:
      a. The while loop does not contain a bool value. This results in an error in the program's semantics and 
         is not related to the vulnerability (since you cannot execute the code you cannot know if the while loop carries out
         a check on str2 of this type: *str2 ! = '\0').
      b. The stringcopy function returns the value of str2 so data can be lost within the function. 
         This problem is related to the style and completeness of the program (IN THIS CASE).
  2. Main:
      a. The stringcopy function would take input buffers that could be null. In this case we have implemented a malloc 
         and we have cast it, so it is necessary to check that the value that takes in input the read function is not null. 
         It can be noted that the tool advises to comment with /*@out@*/ to get more information about this variable.
      b. The buffer variable is not completely defined. This problem is a false negative about security since buff was initialized 
         and definitively defined in the stringcopy function.
      c. The result that returns from the stringcopy function is not used. Here we have a problem not related to security 
         and not having the specifics of the code, I can implement the choice that I prefer (I cast it to void).
      d. The main function must return an int not a void. Also this problem is not related to the security 
         but to the style and completeness of the program since, even if the function does not report any value, 
         it automatically returns 0 (and this has been tested). However, the output of the main function is updated to an int.
      e. The memory allocated within this function is not released. This problem is very important for the vulnerability because: 
         too much allocation carries a buffer overflow and, allocating memory without keeping a global variable that can save 
         the address of the allocation, leads to the loss of the address so as to be unable to implement a free on its. 
         The question to ask is: "If I were to execute the function 10000 times would it go into bufferoverflow?".
         This answer can only provide us with a dynamic tool, but even the static one recognizes this vulnerability. 
         The problem is curbed by a “Free()” on buffer.
      f. The tool reports that argc is not used. This is a variable that provides the exact number of arguments in argv. 
         In reality it is not an important error at first sight but it is easy to see, to the eye, that if argc were 1 
         (since the minimum value is 1) then argv [1] goes into buffer overflow. We can solve the problem in two ways, 
         starting from two different points of view: we did not realize that argv could go into buffer overflow or that we noticed it. 
         The second case has been reported below, in the first case we implement a check on argc: if (argc < 3) return 0.
      g. The stringcopy function is used only within this file. Since it is not an object-oriented programming language, 
         the private method cannot be made, but this question can be solved either by inhibiting Splint's error or by bringing 
         the function into the main. For simplicity we inhibit it.

I conclude by making the following changes in order to solve the problems returned by Splint (the file will contain other errors 
that will be discussed in the conclusion):
char *stringcopy(char *str1, char *str2)
{
// the while loop contains a bool
while (*str2 != ’\0’)
*str1++ = *str2++;
return str2;
}
// the main function returns an int
// argc is defined as unused
int main(/*@unused@*/ int argc, char **argv)
{
char *buffer = (char *)malloc(16 * sizeof(char));
// the problem of the buffer null is eliminated
if (buffer == NULL) return 1;
// the problem of using the returned value is solved
(void)stringcopy(buffer, argv[1]);
printf("%s\n", buffer);
// memory is released
free(buffer);
// return 0 to get a better stylistic code
return 0;
}


File B.c:
#include <stdlib.h>
void func(int fd)
{
char *buf;
size_t len;
read(fd, &len, sizeof(len));
if (len > 1024)
return;
buf = malloc(len+1);
read(fd, buf, len);
buf[len] = '\0';
}
The following problems are illustrated:
   The read function has not been recognized. Not recognizing this function is difficult to say whether it is a security issue 
     or something, plus you cannot know if it is a false positive or a true positive because the tool says only: 
     "I do not find its implementation".
   Len has not been initialized. This, according to Splint, could lead the programmer to forget to initialize it later. 
     It is not related to security.
   Buf could be a null pointer. In reality it is initialized subsequently so it would be a false positive. 
     In this case the tool tells us: "Remember that you have to initialize it otherwise you have a pointer pointing to nothing". 
     This is also the same problem as before, since forgetting to initialize it I could use a null value. 
     Here it is noted that Splint is too hasty to report errors, rather than wait and see if the value has been initialized 
     subsequently avoiding so many false positives.
   As in the previous file we have problems with the malloc because the memory is not released. The reader is referred to the 
    explanation of the malloc of the A.c. file.

The correct code is as follows:
#include <stdlib.h>
void func(int fd)
{
char *buf;
//len has been initialized and defined before its use
size_t len = NULL;
//the read function is not recognized (Flawfinder
// can be used to solve this problem)
read(fd, &len, sizeof(len));
if (len > 1024) { return; }
buf = malloc(len + 1);
//verify that buf is not null
if (buf == NULL) { return; }
read(fd, buf, len);
buf[len] = '\0';
//the space allocated with buf is deallocated
free(buf);
}

File C.c:
#include <stdlib.h>
void func(int fd)
{
char *buf;
size_t len;
read(fd, &len, sizeof(len));
buf = malloc(len+1);
read(fd, buf, len);
buf[len] = '\0';
}

The problems are the same as those of the B.c file but there is a small but substantial difference: 
this piece of code can go into buffer overflow because it does not control the upper limit of buff, via len. The read function, 
as it will be explained in the analysis of the file B.c with Flawfinder, does not do such control so in this case 
the attacker could have a good vulnerability to exploit.
The solution is as follows:
#include <stdlib.h>
void func(int fd)
{
char *buf;
//len has been initialized and defined before its use
size_t len = NULL;
//the read function is not recognized (Flawfinder
// can be used to solve this problem)
read(fd, &len, sizeof(len));
buf = malloc(len + 1);
//verify that buf is not null
if (buf == NULL) { return; }
read(fd, buf, len);
buf[len] = '\0';
//the space allocated with buf is deallocated
free(buf);
}



Flawfinder summary
Flawfinder is a static analysis tool that uses a database of functions in C, not protected, to report to the programmer 
all the possible vulnerabilities related to them. The database used is called "ruleset". Thanks to its use, 
Flawfinder identifies the dangerous functions and reports the problems connected to them. The weak point is that 
it will necessarily produce many false negatives for vulnerabilities not related to functions not in the database; in fact, 
if we put ourselves in the case of C neo-programmers, who use the functions of special libraries for memory management 
and these were stored in the ruleset, then this tool is very advantageous, otherwise, relying only on this tool, 
we could leave a lot of vulnerability in the program. A strong point concerns the controls that 
the tool tells us to perform on the variables that we give in input to the functions (always present in the ruleset). 
A further strength of Flawfinder is the type of output. This is very simple to read and provides error codes, 
allowing you to have a substantial description found on the internet (even with examples). 
A further strong point is that even if the code is incomplete, the tool understands what the system's vulnerabilities could be related
to the functions and reports the problems based on the priority he estimates.

Concluding: Flawfinder in such situations is very useful, but when other methods are implemented, this fails miserably, 
and reports every type of error for each type of function recognized, without checking if that type of problem exists or not.
The difference between the two tools is shown in the conclusion of the report.


File analysis
Before seeing the analysis reported by the tool, we focus on its structure. This consists of final result and Analysis summary. 
The first part concerns the function that is considered harmful for the system and the type of error that must be managed; 
the latter is one of its strong points, in fact on the internet there is a detailed description of the error code 
(ie the whole problem is explained with relative examples). The second part of the output is linked to "Hits", 
ie Flawfinder identifies the danger of the flow by expressing a vote from 0 to 5. The minimum level of global risk is always 1, 
by definition of the documentation. We will focus only on the analysis of Final result.
Finally, we define the following two problems because they are the only ones that have been reported during the analysis of the 3 files. 
CWE-20: improper Iput Validation and CWE-120: Buffer Copy without Checking Size of Input (“Classic Buffer Overflow”). 
The first concerns a check not performed on the input, this can lead to the use of invalid values to perform operations or functions 
on them. The second concerns the possibility that the limit of the size, both upper and lower, is not controlled by a buffer.

File A.c:
char *stringcopy(char *str1, char *str2)
{
while (*str2)
*str1++ = *str2++;
return str2;
}
main(int argc, char **argv){
char *buffer = (char *)malloc(16 * sizeof(char));
stringcopy(buffer, argv[1]);
printf("%s\n", buffer);
}
In this case no error was found, ACCORDING TO HIM. This is because the database does not have the stringcopy function, 
which we implemented. In this case we have several false negatives (see the analysis of the Splint A.c file). 
By relying only on this tool we can say that this piece of code is safe, even if it is not really because stringcopy is 
a custom function of the strcpy. This last is in the Ruleset therefore it is dangerous for our system.


File B.c:
#include <stdlib.h>
void func(int fd)
{
char *buf;
size_t len;
read(fd, &len, sizeof(len));
if (len > 1024)
return;
buf = malloc(len+1);
read(fd, buf, len);
buf[len] = '\0';
}
The final results reported two errors with the following codes: CWE-20 and CWE-120 and with relative mini-description 
(the reader is referred to the introduction of this paragraph to understand the error codes).
Before analyzing the problems you open a parenthesis on the read function: when we talk about this function we will refer 
to the method described in the lesson with its description, so you only have to check up to what index the buffer should and can be
read. The first read function regards the input parameters: fd, &buf and sizeof (len). 
Sizeof (len) is worth 8 when cast to int, this has been tested manually. We therefore have a constant value.
Fd and buf are controlled by the function. The control that the function performs, in addition to those of the null pointer, 
should be as follows: fd> = 0 && fd <sizeof (len) (8). In case this is not done we can always add such checks.
We can conclude that: the first error (CWE-120) reported is a false positive because the only value taken in input is fd and 
this is controlled by the read function, and also the second error (CWE-20) is a false positive because sizeof (len) is constant (>-1).
In the second case we have the same error but this time the variables involved are: fd, buf, len. Again we can assume that 
the read function does the checks explained above, so just check len. Since len is a size_t, then an unsigned int, 
the value is always > -1 so just check the upper limit. This check is done through the following code: "if (len <1024)". 
Since buf is initialized, we have all the correct values that meet the desired criteria. We affirm with certainty that 
this is also a false positive.

In conclusion, at the end of the execution of this tool, the code is correct (trusting only with Flawfinder).
File C.c:
#include <stdlib.h>
void func(int fd)
{
char *buf;
size_t len;
read(fd, &len, sizeof(len));
buf = malloc(len+1);
read(fd, buf, len);
buf[len] = '\0';
}

In this case we have the same output as for file B.c but this time the control on the upper limit of len is not performed. 
We have, if errors are counted according to the codes, 3 false positives out of 4 and the error CWE-120, in the second function read, 
is a problem that would cause the system to crash because if len = 2000 then the buf goes in buffer overflow.
In conclusion, at the end of the execution of this tool, the correct code is that of the B.c.


Conclusion
We can see, after seeing the execution of the tools on each file, that flawfinder, being based on a database,
is not too reliable if you do not use the functions inside.
"Could you say that Splint is much better than the flawfinder?" "No". Unfortunately, Splint not only reports errors of 
vulnerability indeed, it reports too many about other types. In fact, applying it to 100 lines of code would result in an analysis 
of weeks and, in the company, this is not feasible (even in reality); moreover it does not recognize all the functions in the libraries.
Then we can ask ourselves: "If we only used the functions that has flawfinder, could we have a good tool for static analysis?" 
Here too "NO". Splint can find vulnerabilities that are not necessarily related to
functions. In some cases it could report problems linked, in a subordinate manner, to problems of vulnerability (eg argc in A.c).
Splint could be used by inhibiting certain non-safety related problems and resulting in less work. Even if we inhibit such problems 
we may have some important "False negative" outputs, in fact, in the A.c file, the inability of argc is important because 
the minimum number of argv elements is not checked. In conclusion, Splint does not support all libraries so even he is limited 
in this respect.
A parenthesis is opened on the comments: Flawfinder correctly ignores the text within comments and strings, compared to Splint that 
owns it as a main and usable feature.
The speech ends with the following sentence:
"There is no universal tool that can give all the right answers. Each tool has its own specialty, its purpose and its characteristics 
that make it efficient and unique in some blocks of codes and useless in others ".
Problems in A.c
The following file contains issues that only dynamic tools can solve:
• The stringcopy function checks only on str2 but not on str1, result: str1 may not have enough size to copy the entire str2. 
The question that has been asked is the following: "If str1 has no more space and str2 contains at least 2 other values, what happens?" 
Buffer overflow, vulnerability that the attacker can exploit.
• argc is not used but it represents the number of values that argv possesses. If argv had a number of values less than 1, 
then argc is equal to 1, then argv [1] goes into buffer overflow.
• The tools, because STATIC, cannot find the following vulnerability: if argv gets to have a size greater than 16 * size_of (char) 
then executing the stringcopy function and doing only the control on str2, the buffer (ie str1) goes into buffer overflow.
• The last problem concerns the printf. One wonders: all the values taken in input, starting from argv [1], have been checked? 
That is, all the characters are of the ASCII type? No, for this it would be appropriate to validate the input via a white list.
• Str2 may be modified during use, then increase or decrease its size when stringcopy is executed.













Project 2
In this project I added JML annotations to find the bugs. 
file
/* ESC/Java2 Exercise: 
   
   This class implements a Bag of integers, using an array 
 and an integer to represent its cardinality.

   Add JML specs to this class, to stop ESC/Java2 from complaining and 
 to verify that the code performs as requested

   However, beware that there are also errors in the code that you may
   have to fix to stop ESC/Java2 from complaining. (More generally, 
   you may improve the code to make it easier to specify in JML, 
   but _*only*_  if you think this makes the code better/easier 
   to understand).

   The only JML keywords needed for this are
      requires
      invariant 
      ensures 
  
   If you want, you can also use
      non_null
   as abbreviation.


   While developing your specs, it may be useful to use the keywords
      assert
   to add additional assertions in source code, to find out what 
   ESC/Java2 can - or cannot - prove at a given program point.
  
*/

class Bag {

 //@ invariant contents != null;
  int[] contents;
  //@ invariant n >= 0;
  //@ invariant n<=contents.length;
  int n;
  
  //@ requires input != null;
  Bag(int[] input) {
    n = input.length;
    contents = new int[n];
    arraycopy(input, 0, contents, 0, n);
  }

  Bag() {
    n =0;
    contents = new int[0];
  }

/* the next method should remove only the first occurrence of elt */
  void deleteFirst(int elt) {
  //the = has been removed due to buffer overflow problems
    for (int i = 0; i < n; i++) {  
      if (contents[i] == elt ) {
         n--;
         contents[i] = contents[n];
         return;
      }
    }
  }

/* the next method should remove from the array *all* the occurrences of elt */
  void deleteAll(int elt) {
  //the = has been removed due to buffer overflow problems
    for (int i = 0; i < n; i++) {  
      if (contents[i] == elt ) {
         n--;
         contents[i] = contents[n];
      }
    }
  }



  
  int getCount(int elt) {
    int count = 0;
 //the = has been removed due to buffer overflow problems
    for (int i = 0; i < n; i++) 
  //a "=" was added because it generated a syntax error
  if (contents[i] == elt) count++; 
    return count;
  }

  /* Warning: you may have a hard time checking the method "add" below.
     ESC/Java2 may warn about a very subtle bug not easy to spot. 
   */


  void add(int elt) {
    if (n == contents.length) {
 //"+1" has been added because if n = 0 then 2 * n = 0; 
       int[] new_contents = new int[2*n+1]; 
       arraycopy(contents, 0, new_contents, 0, n);
       contents = new_contents;
    }
    contents[n]=elt;
    n++;
  }


//@ requires b != null;
  void add(Bag b) {
    int[] new_contents = new int[n + b.n];
    arraycopy(contents, 0, new_contents, 0, n);
 //"+1" has been removed at n to avoid buffer overflow problems
    arraycopy(b.contents, 0, new_contents, n, b.n);
    contents = new_contents; 
  }


//@ requires a != null;
  void add(int[] a) {
    this.add(new Bag(a));
  }

//@ requires b != null;
  Bag(Bag b) {
  //the object has been initialized to avoid buffer overflow problems
    this(); 
    this.add(b);
  }



//@ requires src != null;
//@ requires dest != null;
//@ requires srcOff >= 0;
//@ requires destOff >= 0;
//@ requires length >= 0;
//@ requires dest.length >= destOff + length;
//@ requires src.length >= srcOff + length;
  private static void arraycopy(int[] src,
                                int   srcOff,
                                int[] dest,
                                int   destOff,
                                int   length) {
 //the = has been removed due to buffer overflow problems
    for( int i=0 ; i<length; i++) {
       dest[destOff+i] = src[srcOff+i];
    }
  }
  
}



•	In the end, do you think that you found all problems? Are you certain now that the code is correct?
  I think I found all the problems, but now, because I do not know if, in the future, they can find some other way to attack my system.
  I can say with certainty that the program is not safe because I added annotations, that is, I have ensured a simpler reading
  of the code.
  The code would be correct if I introduced, in the code, the controls expressed in the annotations then I can say to have a code, 
  at the moment, correct.
  Example: Bag (int [] a) {
  if (a == null) new throw Nullpointerexception("null value");
  ...}
  So I always handle the exception.

•	Can you think of ways in which the tool or the specification language could be improved? 
  Yes, ESC / JAVA2 should tell us not only the error but also what causes it so you can check if you need to change the code or 
  add an annotation (congruent to the reported error). Finally, it could help the programmer by reporting the possible solutions 
  for each error reported.
•	Instead of the tool we used, can you think of other ways (formal or informal, tool-supported or not) to find the problems
  that the tool found? If so, would these alternatives
    o	find fewer of the problems, the same, or more?
    o	find problems sooner or later than the current approach?
    o	require more work or less work?
    o	provide you with more confidence or less confidence that the code is correct?
  
  Yes, you can perform a dynamic analysis of the code by testing it either in white-box or in balck-box (if possible). 
  The order is important because in the first case there are problems that were not found during the analysis,
  the design or the programming; in the second case we test a possible external attack by simulating a malintenzinato 
  that does not know the system (always if possible).
    1. This can not be said because it depends on the code and the tools used, however, with this method, and with the supervision 
       of an expert, you can TEST more attacks.
    2. Find them later because it takes more time to test the code.
    3. Naturally it requires a lot more work.
    4. If you test the program correctly, you have a higher security percentage but it is not always SURE.





Group Project on FluxBB (https://fluxbb.org/)


Group Project Lorenzo Manduca – Andrea Magnante – Matteo Liberti Preface All tests were carried out on the application Fluxbb 
Current stable release (v1.5.10)with default settings. FluxBB is fast, light, user-friendly forum software for your website. 
It’s designed as a good alternative to some of the traditional feature heavy forum applications. 
It is easy to use and has a proven track record of stability and security making it an ideal choice of forum for your website.
First Step The assigned requirements were: 
  - V7: Cryptography at rest verification requirements
  - V10: Communications security verification requirements
There are more ways to find out what we are looking for. In particular, trying to find possible vulnerability within Fluxbb, 
we used the suggested tools (RIPS, RATS) and also OWASP ZAP, WIRESHARK. After that we did a code review with grep to find, 
using key word, possible vulnerable file. 
   TOOLS 
      1. RIPS
          RIPS is the most popular static code analysis tool to automatically detect 
          vulnerabilities in PHP applications. By tokenizing and parsing all source code files, RIPS is able to transform PHP 
          source code into a program model and to detect sensitive sinks (potentially vulnerable functions) that can be tainted 
          by user input (influenced by a malicious user) during the program flow. Besides the structured output of found 
          vulnerabilities, RIPS offers an integrated code audit framework.
    2. RATS 
        The Rough Auditing Tool for Security is an open source tool developed by Secure Software Engineers. 
        Since then it has been acquired by Fortify, which continues to distribute it free of charge (here ). 
        It scans various languages, including C, C++, Perl, PHP and Python. It is very fast and can easily be integrated 
        into a building process without causing noticeable overhead. Unfortunately its utility is rather limited for PHP 
        as it does not find Cross-Site Scripting or SQL Injection vulnerabilities.
    3. OWASP ZAP 
        The OWASP Zed Attack Proxy (ZAP) is one of the world’s most popular free security tools. It can help you automatically
        find security vulnerabilities in your web applications while you are developing and testing your applications. 
        Its also a great tool for experienced pentesters to use for manual security testing. 
    4. WIRESHARK. 
        Wireshark is the world’s foremost and widely-used network protocol analyzer. 
        It lets you see what’s happening on your network at a microscopic level. Wireshark has a rich feature set which 
        includes the following: 
             Deep inspection of hundreds of protocols, with more being added all the time 
             Live capture and offline analysis  Standard three-pane packet browser 
             Captured network data can be browsed via a GUI
Report of the tools output From a first overview of tools output, 
It’s possible to understand that they are not very useful to find out if there are vulnerabilities in FLUXBB applications 
that concern V7 and V10 requirements. But it’s possible to use tools output to find which files can have security problems, 
for example the functions.php file.

Second Step
  Therefore, all assigned requirements were verified and if they were satisfied or not.
    V7: Cryptography at rest verification requirements
          Control objective
            Ensure that a verified application satisfies the following high level requirements:
                 That all cryptographic modules fail in a secure manner and that errors are handled correctly.
                 That a suitable random number generator is used when randomness is required.
                 That access to keys is managed in a secure way.
  Requirements
      Requirement ID
        V7.2 
          Title: Verify that all cryptographic modules fail securely, and errors are handled in a way that does not enable 
                 oracle padding.
          Description: Data sent over the internet is not further encrypted by FluxBB and oracle padding is enabled when no protocols 
                       (https) are used on which this attack can be performed. 
          Testing: For the first point, a manual static analysis of the code was performed, verifying whether the data was encrypted
                    before being sent. For the second point, it is up to the system administrator to use protocols that do not enable 
                    oracle padding. 
          Proposed Solution: We need to update the system by coding cryptographic modules that do not fail or if they should fail 
                    then they are enabled against oracle padding using a good encryption.
          Verdict: NOT PASSED

      Requirement ID
        V7.6 
            Title: Verify that all random numbers, random file names, random GUIDs, and random strings are generated using 
                   the cryptographic module’s approved random number generator when these random values are intended 
                   to be not guessable by an attacker
            Description: If the functions for random values are not approved by the cryptographic module then there is at least
                         one case in which the attacker can calculate the random values generated by our system. 
            Testing: A manual analysis of the code was carried out. The functions that affect this point are contained in functions.php
                    and srand.php. This analysis showed that every function used is either pseudo-random or generates values 
                    not approved by cryptographic modules. We can state this thanks to the php documentation which shows 
                    the descriptions of these functions. 
            Proposed Solution: The functions used to generate random values with other more recent ones approved by 
                    the cryptographic module must be updated. 
            Verdict: NOT PASSED
      Requirement ID
        V7.7 
            Title: Verify that cryptographic algorithms used by the application have been validated against FIPS 140-2 
                   or an equivalent standard.
            Description: It must be verified that the system has been validated against FIPS 140-2. FIPS 140-2 has 4 levels. 
                         We expect the first two to be satisfied by an Open-source application, instead, the other two for business 
                         and / or military software. The reader is referred to the description of the FIPS 140-2 points. 
            Testing: A manual analysis of the code was made to verify the cryptographic and random modules and, 
                     by reviewing every point of the V7, it is possible to understand if this application complies with 
                     the criteria of level 2 (level 1 must be satisfied to check level 2). Unfortunately, it does not even respect 
                     the first level because encryption is not secure, so it does not even comply with point 2. 
            Proposed Solution: 
                Point 1: replace cryptographic functions and random values with more recent ones that are approved 
                            by cryptographic modules.
                Point 2: add features to the system that show evidence of tampering and handle them appropriately.
                In short, update the system so as to satisfy at least the first two points of the FIPS 140-2 
                Verdict: NOT PASSED
      Requirement ID
        V7.8 
            Title: Verify that cryptographic modules operate in their approved mode according to their published security policies.
            Description: It is necessary to verify that the cryptographic modules described in the system documentation coincide with those actually implemented.
                         There is no type of documentation. 
            Testing: - 
            Proposed Solution: -
            Verdict: UNVERIFIABLE
      Requirement ID
        V7.9
            Title: Verify that there is an explicit policy for how cryptographic keys are managed (e.g., generated, 
                   distributed, revoked, and expired). Verify that this key lifecycle is properly enforced.
        Description: There is no type of key policy. Their life cycle is not optimal, rather, it is precarious because
                     they are created when the user registers and are changed if the user changes the value on which the key is based.
                     Continuing, these values are based on random functions not approved by the cryptographic module. 
        Testing: Manual static analysis of the tool. A static analysis was performed aimed at the functions.php file 
        Proposed Solution: Use the appropriate functions for generating random keys and implement their appropriate life cycle. 
        Verdict: NOT PASSED
      Requirement ID
        V7.11 
          Title: Verify that all consumers of cryptographic services do not have direct access to key material. 
                 Isolate cryptographic processes, including master secrets and consider the use of a hardware key vault (HSM).
          Description: This point is too high for an application of this type, in addition, anyone has direct access to the material. 
                       The HSM would be useless for an open-source tool. 
          Testing: - 
          Proposed Solution: - 
          Verdict: UNVERIFIABLE
      Requirement ID
        V7.12 
           Title: Personally Identifiable Information should be stored encrypted at rest and ensure that 
                  communication goes via protected channels.
        Description: The personally identifiable information is passwords and cookies. As for the protected channels: 
                     they are those used by the Internet so we can say that they are safe, for now. 
        Testing: After a manual static analysis, we realized that both cookies and passwords are encrypted. This has been verified 
                 by opening the database and checking the passwords; instead, for cookies, these have been analyzed 
                 through Google Chrome, opening the settings dedicated to the developers. There are no particular physical channels 
                 so no tests have been performed. 
        Proposed Solution: - 
        Verdict: PASSED
      Requirement ID
        V7.13 
          Title: Verify that sensitive passwords or key material maintained in memory is overwritten with zeros as soon as it no
                 longer required, to mitigate memory dumping attacks.
        Description: A memory dump attack is the capture and use of RAM content that was written to a storage drive during 
                     an unrecoverable error, which was typically triggered by the attacker. Developers commonly use memory dumps 
                     to gather diagnostic information at the time of a crash to help them troubleshoot issues and 
                     learn more about the event. Hackers access memory dumps to obtain otherwise protected data or information 
                     or to compromise the host computer and/or systems it connects to.
        Testing: -
        Proposed Solution: FluxBB uses PHP and what this requirement is asking for it’s not possible to made with this language. 
                           Internally it may be possible to do, however it is currently outside of our control.
        Verdict: UNVERIFIABLE
      Requirement ID
        V7.14 
            Title: Verify that all keys and passwords are replaceable, and are generated or replaced at installation time.
            Description: -
            Testing: Take a look at all fluxbb pages and testing if it’s possible to change password and so on.
            Proposed Solution: Within FluxBB all specified keys and passwords can be changed at any time by anyone 
                               with sufficient privilege. It is the responsibility of the system administrator to ensure that
                               new passwords and keys are generated at the time of installation.
            Verdict: PASSED
      Requirement ID
        V7.15 
            Title: Verify that random numbers are created with proper entropy even when the application is under heavy load, 
                   or that the application degrades gracefully in such circumstances.
        Description: -
        Testing: -
        Proposed Solution: As wrote before that 7.6 point is not verified (owasp asked to verify that all random numbers, etc. are generated using a cryptographic module with no vulnerability) at the same way v7.15 is not satisfied, because owasp asked the same thing but to verify it when the application is under heavy load.
        Verdict: NOT PASS

V7 requirement – CONCLUSION
The tool must be ABSOLUTELY updated as it has serious security problems regarding the encryption of passwords, 
the generation of random values and the encryption of cookies.
As you can see, almost all the points fail because the program uses functions that are too old, now insecure or that 
no longer meet the current security criteria.
                  
V10: Communications security verification requirements
Control objective
   Ensure that a verified application satisfies the following high level requirements:
       That TLS is used where sensitive data is transmitted.
       That strong algorithms and ciphers are used at all times.
   Requirements
       Requirement ID
           V10.1 
            Title: Verify that a path can be built from a trusted CA to each Transport Layer Security (TLS) server certificate, 
            and that each server certificate is valid.
        Description: SSL and TLS protocols require that the SSL or TLS clients and servers that connect exchange certificates. 
                     The security context that uses a certificate must "trust" the certificate authority (CA) 
                     that issued the certificate. A certificate authority is trusted by a security context when a certificate 
                     that is issued by the certificate authority is installed in either that user account or 
                     in the trusted root certificate store for the security context the server is running in.
        Testing: -
        Proposed Solution: Simplest verification for this is to let the browser do the work and visit the application with 
                           a modern browser. This is the responsibility of the system administrator and the way of how the server
                           that he uses is setted. Indeed Fluxbb allows to use both HTTPS and HTTP, as we can find making a code review.
        Verdict: UNVERIFIABLE
      Requirement ID
        V10.3 
            Title: Verify that TLS is used for all connections (including both external and backend connections) 
                   that are authenticated or that involve sensitive data or functions, and does not fall back to insecure or unencrypted
                   protocols. Ensure the strongest alternative is the preferred algorithm.
          Description: -
          Testing: -
          Proposed Solution: We can verify this point doing a code review. Fluxbb provides support for connecting to all resources 
                            via TLS secured connections. It is the responsibility of the system administrator to ensure
                            that all Fluxbb’s connections are configured to connect to are configured via TLS portals.
          Verdict: PASS
      Requirement ID
        V10.4 
            Title: Verify that backend TLS connection failures are logged.
            Description: -
            Testing: -
            Proposed Solution: The system administrator will have the responsibility to check this point.
            Verdict: UNVERIFIABLE
      Requirement ID
        V10.5 
            Title: Verify that certificate paths are built and verified for all client certificates using configured trust anchors and revocation information.
        Description: -
        Testing: -
        Proposed Solution: As in the previous requirement, it’s the responsibility of the system administrator.
        Verdict: UNVERIFIABLE
      Requirement ID
        V10.6 
        Title: Verify that all connections to external systems that involve sensitive information or functions are authenticated.
        Description: -
        Testing: -
        Proposed Solution: The system administrator will have the responsibility to check this point.
        Verdict: UNVERIFIABLE
      Requirement ID
        V10.8 
        Title: Verify that there is a single standard TLS implementation that is used by the application that is configured 
               to operate in an approved mode of operation.
        Description: -
        Testing: -
        Proposed Solution: The system administrator will have the responsibility to check this point.
        Verdict: UNVERIFIABLE 
      Requirement ID
        V10.10 
          Title: Verify that TLS certificate public key pinning (HPKP) is implemented with production and backup public keys. 
                 For more information, please see the references below.
          Description: HTTP Public Key Pinning (HPKP) is an Internet security mechanism delivered via an HTTP header 
                       which allows HTTPS websites to resist impersonation by attackers using mis-issued  
                       otherwise fraudulent certificates. In order to do so, it delivers a set of public keys to the client (browser), 
                       which should be the only ones trusted for connections to this domain. Testing
          Testing: - 
          Proposed Solution: The system administrator will have the responsibility to check this point.
          Verdict: UNVERIFIABLE
      Requirement ID
        V10.11 
          Title: Verify that HTTP Strict Transport Security headers are included on all requests and for all subdomains, 
                 such as Strict-Transport-Security: max-age=15724800; includeSubdomains
        Description: HTTP Strict Transport Security (HSTS) is a web security policy mechanism that restricts web browsers 
                     to access web servers only over HTTPS and so helps to protect websites against protocol downgrade attacks 
                     and cookie hijacking. This ensures the connection cannot be establish through an insecure HTTP connection 
                     which could be susceptible to attacks. HSTS is defined in the response header as Strict-Transport-Security 
                     and once the supported browser receives that header it knows to deliver all information over HTTPS.
        Testing: We started the application using MAMP PRO (establish HTTPS connection) and then we inspected through the use 
                 of the Chrome Browser the response header of any page of the site (in our case the page login.php)
                 We noticed that the header "Strict-Transport-Security: max-age=31536000; includeSubDomains" was actually present. 
                 The parameter "max-age" differs from what is required in the specification but, since it is expressed in seconds 
                 and 31.536.000 seconds are a good approximation of a year, we can say that through the use of HTTPS connection 
                 the point is verified correctly. This requirement is not verified, as we expected, using HTTP connections.
        Proposed Solution: The system administrator will have the responsibility to check and configure it correctly.
        Verdict: WE DON’T KNOW
        
      Requirement ID
        V10.12 
          Title: Verify that production website URL has been submitted to preloaded list of Strict Transport Security domains maintained
                 by web browser vendors. Please see the references below.
        Description: This requirement allows that HSTS to be hardcoded in the web browser. It solves the "Trust On The First Use" 
                     problem. In fact, HSTS for a domain can be registered on, for example, https://hstspreload.org
        Testing: -
        Proposed Solution: The system administrator will have the responsibility to check this point.
        Verdict: UNVERIFIABLE 
      Requirement ID
        V10.13 
          Title: Ensure forward secrecy ciphers are in use to mitigate passive attackers recording traffic.
          Description: Perfect Forward Secrecy is an attribute of the specific key exchange mechanisms in SSL/TLS security protocols 
                       that implies the independence of the session key generated during the secure session establishment from 
                       the set of long-term Public and Private keys and the session keys used in previous sessions.
                       In fact, by generating a unique session key for every session that a user initiates, even the compromise 
                       of a single session key will not affect any data other than that exchanged in the specific session protected 
                       by that particular key.
          Testing: Only the Diffie-Hellman Ephemeral (DHE) and its lighter version based on Elliptic Curves (ECDHE) key exchange 
                   mechanisms provide the Forward Secrecy.
                   Is necessary configure servers (Apache/Nginx) to use the ECDHE suites at the top of list, followed by the DHE suites.
                   Is also necessary to enable other non-DH-key-exchange cipher suites from the list of cipher suites offered 
                   by the SSL Client.
          Proposed Solution: The system administrator will have the responsibility to check this point.
          Verdict: UNVERIFIABLE 
        Requirement ID
           V10.14 
           Title: Verify that proper certification revocation, such as Online Certificate Status Protocol (OCSP) Stapling, 
                  is enabled and configured.
        Description: OCSP is an Internet protocol used for obtaining the revocation status of an X.509 digital certificate. 
                     It allows to verify the revocation of certificates in real time, offering a faster, easier 
                     and more reliable system for the validation of digital certificates than that offered by the traditional download
                     and processing of Certificate Revocation Lists (CRL).
        Testing: -
        Proposed Solution: The system administrator will have the responsibility to check this point.
        Verdict: UNVERIFIABLE
      Requirement ID
        V10.15 
        Title: Verify that only strong algorithms, ciphers, and protocols are used, through all the certificate hierarchy, 
               including root and intermediary certificates of your selected certifying authority.
        Description: To have a secure communication, is necessary:
             Use Strong Private Key (for example RSA 2048 bit that provide about 112 bits of security or ECDSA at 256 bits that provide 128 bits of security.
             Protect Private Keys (Generate private keys on a trusted computer with sufficient entropy)
             Obtain Certificates from a Reliable CA
             Use Strong Certificate Signature Algorithms (for example SHA256)
             Use Complete Certificate Chains
             Use Secure Protocols (SSL/TLS)
             Use Secure Cipher Suites (using AEAD suites provide strong authentication and key exchange, forward secrecy, and encryption of at least 128 bits)
             Select Best Cipher Suites
             Use Forward Secrecy (is better to use ECDHE suites in order to enable forward secrecy with modern web browsers)
             Encrypt Everything
             Secure Cookies
             Secure HTTP Compression
             Deploy HTTP Strict Transport Security
             Deploy Content Security Policy
             Do Not Cache Sensitive Content
             Public Key Pinning 
        Testing: -
        Proposed Solution: The system administrator will have the responsibility to check this point.
        Verdict: UNVERIFIABLE
      Requirement ID
        V10.16 
          Title: Verify that the TLS settings are in line with current leading practice, particularly as common configurations, 
                 ciphers, and algorithms become insecure.
          Description: There are five protocols in the SSL/TLS family: SSL v2, SSL v3, TLS v1.0, TLS v1.1, and TLS v1.2:
               SSL v2 is insecure and must not be used. This protocol version is so bad that it can be used to attack RSA keys
                 and sites with the same name even if they are on an entirely different servers (the DROWN attack).
               SSL v3 is insecure when used with HTTP (the POODLE attack) and weak when used with other protocols. 
                  It’s also obsolete and shouldn’t be used.
               TLS v1.0 is also a legacy protocol that shouldn't be used, but it's typically still necessary in practice. 
                  Its major weakness (BEAST) has been mitigated in modern browsers, but other problems remain.
              Wireshark sniffing packets when MAMP PRO (and HTTPS) is used:
               TLS v1.1 and v1.2 are both without known security issues, but only v1.2 provides modern cryptographic algorithms.
                 TLS v1.2 should be used as main protocol because it's the only version that offers modern authenticated encryption 
                 (also known as AEAD). Work is currently under way to design TLS v1.3, with the aims to remove all obsolete and 
                 insecure features and to make improvements that will keep our communication secure in the following decades.
          Testing: Using wireshark sniffing packets and different connection to verify that when used MAMP PRO (and HTTPS connection)
                   than TLS 1.2 is setted as you can see in the picture below. At the same time when used MAMP (and HTTP connection) 
                   sensitive data are visible.
          Proposed Solution: The system administrator will have the responsibility to check this point.
          Verdict: UNVERIFIABLE

V10 requirement – CONCLUSION
The V10 requirement, as you can see point by point, is the responsibility of the network administrator who must be able to host
the application in the correct and above all safe way. So we can remove, instead, the responsibility to the developers of FluxBB 
that is definitely in the background. It would be nice for the application to point out, to the end user, in the documentation to pay
attention to what could be the vulnerabilities due to the hosting of the application, with particular attention to the use of HTTPS
and TLS 1.2 protocol.









